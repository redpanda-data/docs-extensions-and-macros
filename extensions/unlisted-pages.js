module.exports.register = function ({ config }) {
  const { addToNavigation, unlistedPagesHeading = 'Unlisted Pages' } = config
  const logger = this.getLogger('unlisted-pages-extension')
  this
    .on('navigationBuilt', ({ navigationCatalog, contentCatalog }) => {
      contentCatalog.getComponents().forEach(({ versions }) => {
        versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
          if (component === 'api') return;
          if (!nav) return
          const navEntriesByUrl = getNavEntriesByUrl(nav)
          const unlistedPages = contentCatalog
            .findBy({ component, version, family: 'page' })
            .filter((page) => page.out)
            .reduce((collector, page) => {
              if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
              logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
              return collector.concat(page)
            }, [])
          if (unlistedPages.length && component === 'redpanda-connect') {
            // Some component pages for Redpanda Connect  are autogenerated. This function tries to add unlisted component pages to the nav in case a new one gets created without updating the nav.
            addRedpandaConnectPagesToNav(nav[0].items, unlistedPages)
          } else if (unlistedPages.length && addToNavigation) {
            nav.push({
              content: unlistedPagesHeading,
              items: unlistedPages.map((page) => {
                return { content: page.asciidoc.navtitle, url: page.pub.url, urlType: 'internal' }
              }),
              root: true,
            })
          }
        })
      })
    })
}

function getNavEntriesByUrl (items = [], accum = {}) {
  items.forEach((item) => {
    if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
    getNavEntriesByUrl(item.items, accum)
  })
  return accum
}

function addRedpandaConnectPagesToNav(navItems, pages) {
  // get the Components nav section
  let componentsSection = navItems.find(item => item.content === 'Components');
  if (!componentsSection) return

  pages.forEach(page => {
    const dirname = page.out.dirname;
    if (!dirname.includes('/components/')) return
    const heading = page.asciidoc.attributes.doctitle;
    const pathParts = dirname.split('/').slice(2); // Get the type
    // get existing nav items inside the Components tree
    let currentLevel = componentsSection.items;

    pathParts.forEach((part, index) => {
      const capitalizedPart = part.charAt(0).toUpperCase() + part.slice(1);
      let section = currentLevel.find(item => item.content === capitalizedPart);
      if (!section) {
        section = { content: capitalizedPart, items: [], root: index === 0 };
        currentLevel.push(section);
      }
      currentLevel = section.items;
    });

    currentLevel.push({ content: page.asciidoc.navtitle || page.src.stem, url: page.pub.url, urlType: 'internal' });
  });
}